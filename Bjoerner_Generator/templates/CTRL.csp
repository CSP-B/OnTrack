{-
 Date: $date
 Notes:  CSP Controller for $model model with $numTrains train#if ($numTrains > 1)s#end
 
 Generated by: Automatically produced by Version $version of TrackScheme2CSPB tool
 Authors of Tool: Phillip James and Matthew Trumble
 Authors of Model: Moller, Nguen, Roggenbach, Schneider, Treharne
 Corresponding Authors: S.Schneider@surrey.ac.uk, H.Treharne@surrey.ac.uk
 
 Description: 
 A CSP process to guide the Interlocking.mch

 First open the Interlocking.mch file as usual in ProB
 Then select the menu item
        Menu -> File -> Open Special -> Use CSP File to Guide B
 You have to be in normal mode to see this menu item (not in beginner mode)

 Comments: This model describes the train behaviour of an open system with trains exiting and remaining on the exit track. 

 
-}
[%
var cspScript1 : CSP!CSPScript;
cspScript1 := CSP!CSPScript.all().at(0);
%]

-- datatype definitions corresponding to those given in the Context.mch
datatype TRAIN = albert | bertie

datatype SIGNAL = red | green
[%
for (dt in cspScript1.dataType)
{
	if( dt.isDefined() ) --  and not(dt.name.isNativeCSPType())) 
	{
		out.println( dt.write(0) );
		--out.println();
	}
}
%]
datatype ANSWERS = yes | no

--both these sets defined the end points of an open system
[%
for (st in cspScript1.set)
{
	out.println( st.write(0) );
}
%]
ALLTRACK = POS
TRACK = diff(ALLTRACK,{nullTrack})

--the rest of this file is the same for all track plans
-- define channels with names that correspond to the B operations in the Interlocking.mch
channel enter: TRAIN.ENTRY
channel exit: TRAIN.EXIT
channel nextSignal : TRAIN.SIGNAL
channel move : TRAIN.ALLTRACK.ALLTRACK
channel stay : TRAIN.ALLTRACK
channel request : ROUTE.ANSWERS
channel release : ROUTE.ANSWERS
--definition of error channels
channel collision, derailment


--controller process to deal with route requests and releasing of routes
RW_CTRL =
  ([] r : ROUTE @ request!r?ans -> RW_CTRL)
  []
  ([] r : ROUTE @ release!r?ans -> RW_CTRL)  

--definition of individual train control process
--each train starts off the track plan and after leaving remains on the exit track
TRAIN_OFF(t) = enter!t?newp -> TRAIN_CTRL(t,newp)
TRAIN_EXIT(t) = []e: EXIT @ (move.t.e?newp -> TRAIN_EXIT(t))

--process to determine movement of train, trains do not move through red signals
TRAIN_CTRL(t,pos) =
(not(member(pos,EXIT)) and member(pos,SIGNALHOMES) & nextSignal!t?aspect -> 
   if (aspect==green)
   then
      (move!t.pos?newp -> TRAIN_CTRL(t,newp))
      []
      (stay!t.pos -> TRAIN_CTRL(t,pos))
   else
      stay!t.pos -> TRAIN_CTRL(t,pos))
[]
(not(member(pos,EXIT)) and not(member(pos,SIGNALHOMES)) &
   ((move!t.pos?newp -> TRAIN_CTRL(t,newp))
    []
    (stay!t.pos -> TRAIN_CTRL(t,pos))))
[]
(member(pos,EXIT) & 
    ((stay!t!pos -> TRAIN_CTRL(t,pos))
     []
     (exit!t.pos -> TRAIN_EXIT(t))))


--definition of all train processes which are not initially on the tracks
ALL_TRAINS = ||| t : TRAIN @ TRAIN_OFF(t)

--definitons to model collision and derailment
--these processes serve no purpose in the CSP but are included so that the alphabets of the CSP and B match
--they are events that are used in the CTL model checking
ERR = (collision -> ERR) [] (derailment -> ERR)

--define the composition of the route controller, all trains and the error events
--control the entry of the two trains in the model to limit the state space
CTRL = RW_CTRL ||| ALL_TRAINS ||| ERR
        [|{| enter |}|]
       (#foreach ($String in $trains)enter.$String?p -> #end#**#STOP)

--define a restricted controller so that events which do not change the state can be ignored
RESTRICTED_CTRL = CTRL [ {| request, release, enter, exit, nextSignal, move, stay, collision, derailment |}
                          || union(union({| stay, #foreach ($String in $trains)nextSignal.$String#**#.red#if ($foreach.hasNext), #end#end |},
                                         { request.r.no | r <- ROUTE}),
                                   { release.r.no | r <- ROUTE}) ] STOP

-- Main process which enables the B and CSP to be analysed together
is needed in order to run through ProB
MAIN = RESTRICTED_CTRL

[%

@cached
operation Integer indent() : String {
	var indentation : String := '';
	var i: Integer := 0;
	while(i < self) {
		indentation := indentation + '';
		i := i + 1;
	}
	return indentation;
}

operation DatatypeItemList write(i : Integer) : String 
{
	var indt : String := i.indent();
	var toReturn : String := '';
	
	if(self.size > 0) 
	{
		var ppli : DatatypeItem := self.firstItem;
		toReturn := indt;
		var sep : String := '';
		
		while(ppli.isDefined()) 
		{
			toReturn := toReturn + sep + ppli.name;
			ppli := ppli.preceeds;
			sep := ' | ';
			--ppli.name.println('<><><><<><><><><><>');
		}

	}
	return toReturn;
}

operation Datatype write(i : Integer) : String 
{
	var indt : String := i.indent();
	var nm : String := '';
	
	if(self.typeName.isDefined() and self.itemList.isDefined()) 
	{
			nm := indt + 'datatype ' + self.typeName + ' = ' + self.itemList.write(i + 1);
	}
		
	return nm;
}


operation SET write(i : Integer) : String 
{
	var toReturn : String;
	if(not(self.name = '')) 
	{
		var indt : String := i.indent();
		toReturn:= indt+self.name+' = '+(i+1).indent() + '{ ';
		var sep : String := '';
		
		for(el in self.item) 
		{
			if(el.item.isDefined()) -- mutually exclusive: either is a typeditem or event 
			{ 
				toReturn := toReturn + sep + el.item.name ;
			} 
			else 
			{
				toReturn := toReturn + sep + el.event.writeEvent(true);
			}
			sep := ', ';
		}
		
		toReturn := toReturn + ' }';
	}
	else 
	{
		toReturn := '';
	}
	return toReturn;
}

%]
