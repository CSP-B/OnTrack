MACHINE Interlocking

/* Date: Wed Aug 06 17:47:51 BST 2014
 * Notes: supporting doubleJunction.bjoernercomplete model
 * Automatically generated by TrackScheme2CSPB tool version 0.1
 * Authors of Tool: Phillip James and Matthew Trumble
 * Authors: Moller, Nguyen, Roggenbach, Schneider, Treharne
 * Corresponding Authors: S.Schneider@surrey.ac.uk, H.Treharne@surrey.ac.uk
 *
 */


SEES  DJContext, 
      DJTopology, 
      DJControlTable,
       DJReleaseTable

 SETS
       ANSWERS = {yes,no}
 

VARIABLES
	pos,
   nextd,
    
	signalStatus,

   normalPoints,
	reversePoints,
        
   currentLocks
   
	

/* Collision-freedom:
   We want to allow behaviour of model to allow more than one train on the same track 
   to show that combined CTRL||Interlocking system can never evolve to this behaviour, 
   so this Interlocking machine on its own will not ensure this. 
*/
INVARIANT
      pos : TRAIN +-> ALLTRACK &
      /* pos - { (t,Exit) | t : TRAIN  }  : TRAIN >+> TRACK & */

      nextd : TRACK +-> TRACK &
    /*  nextd  = staticNext \/ {(t1,t2) | t1 : TRACK & t2: TRACK & #(p).(p : POINTS & (t1,t2) = dynamicNext(p,pointPosition(p)))}  &
     */
     nextd - { (t,Exit) | t : TRACK  }  : TRACK >+> TRACK & 

      signalStatus : SIGNAL --> SIGNALSTATUS &

      normalPoints <: POINTS & 
      reversePoints <: POINTS & 
      normalPoints /\ reversePoints = {} &
      normalPoints \/ reversePoints = POINTS &

      currentLocks  : ROUTE <-> POINTS &
      currentLocks <: lockTable

/* Initially all tracks empty, all signals red, no trains on a track */
INITIALISATION
	BEGIN
	pos := {} ||
        nextd :=  staticNext \/ {(t1,t2) | t1 : TRACK & t2: TRACK & #(p).(p : POINTS & (t1,t2) = dynamicNext(p,normal))} || 
 
	signalStatus := SIGNAL * {red} ||
 
        normalPoints := POINTS ||
        reversePoints := {} ||

         currentLocks := {} 

     	END

OPERATIONS

/*
   Description: PositionA train can arrive at an ENTRY track if it's not already on the junction
   Inputs: a train and an entry position which is not occupied
   Outputs: no outputs
 */
enter(t,p) =
PRE t : TRAIN & t /: dom(pos) & p : ENTRY & p /: ran(pos) 
THEN
  pos(t) := p 
END;


/*exit(t,p) =
PRE t : TRAIN & p : EXIT & pos(t) = p
THEN
  pos(t) := p 
END;
*/


/* Collision operator to detect collision
   to check for collision, use CTL formula AG(not e[collision])
*/
collision =
SELECT #(t1,t2).(t1 : TRAIN & t2 : TRAIN & 
                 t1:dom(pos) & t2:dom(pos) & t1 /= t2 &
                 pos(t1) /: EXIT & pos(t2) /: EXIT & 
                 pos(t1) = pos(t2))
THEN skip
END;

/* Derailment operator to detect derailment
   to check for collision, use CTL formula AG(not e[derailment])
*/
derailment =
SELECT #(t1).(t1 : TRAIN & t1:dom(pos) & pos(t1) = nullTrack)
THEN skip
END;


/*
   Description: Determine the signal status available to the train t making the request
   Inputs: a train
   Outputs: aspect of a signal
 */
s <-- nextSignal(t) = 
PRE t : TRAIN & t : dom(pos) & pos(t) : ran(homeSignal) 
THEN
	s := signalStatus(homeSignal~(pos(t)))
END;


/* Description: Move the train
   Inputs: a train which is provided by CTRL
   Outputs: the current position of the train and the new position of the train which are inputs to CTRL
 */
currp, newp <-- move(t) =
PRE t : TRAIN & t : dom(pos) 
THEN
   IF (pos(t) /: dom(nextd)) THEN
      	      LET track BE
	        track = nullTrack 
	      IN
      currp := pos(t) ||
		pos(t) := track ||
		newp := track 
	      END
   ELSE
	      LET track BE
	        track = nextd(pos(t))
	      IN
      currp := pos(t) ||
		pos(t) := track ||
		newp := track ||
		currentLocks := currentLocks - releaseTable[{track}] ||
		IF (pos(t) : ran(homeSignal))
		THEN
		   signalStatus( homeSignal~(pos(t))) := red
		END
	      END
   END
END;


/*
   Description: deal with request which has been inputted into the CSPCSP CTRL, e.g. request(A8) 
   Inputs: a route from the controller
   Outputs: boolean result indicating whether route is granted or not
 */
    bb <-- request(route) = 
    PRE route : ROUTE THEN
    LET emptyTracks BE emptyTracks = TRACK - ran(pos) IN
       /* are the tracks for a route empty */
       IF  ((signalStatus(signal(route)) = red)  & 
            (clearTable(route) <: emptyTracks ))
       THEN
          LET unlockedPoints BE
            unlockedPoints = POINTS - ran(currentLocks)
          IN
              /* all points in right position or unlocked */ 
              IF ( (normalTable[{route}] <: normalPoints \/ unlockedPoints ) & 
                   (reverseTable[{route}] <: reversePoints \/ unlockedPoints))
              THEN
                LET np, rp BE
                 np =   (normalPoints \/ normalTable[{route}]) - reverseTable[{route}] &
                 rp = (reversePoints \/ reverseTable[{route}]) - normalTable[{route}]
                IN
                   /* move points on the route that need to be moved */
                   normalPoints := np  ||
                   reversePoints := rp ||
                   /* for each point p of route, lock p */
               	   currentLocks := currentLocks \/  ({route} <| lockTable) ||
		   /* set signal of route to greeen */
         	    signalStatus(signal(route)) := green||
		    /* grant the request */ 
                     bb := yes ||
                     /* update topology, the next track position given that the point might have changed */
                      nextd  := staticNext \/ dynamicNext[(np*{normal} \/ rp*{reverse})]
 
                  END /* end let */
             ELSE
               /* refuse request */
               bb:= no
             END /* end if */
           END /* end let */
        ELSE
          /* refuse request */
          bb:= no
        END /* end if */
        END /* let */
    END; /* end pre */

  bb <-- release(route) =
  PRE route : ROUTE 
  THEN 
  LET emptyTracks BE emptyTracks = TRACK - ran(pos) IN
    IF 
       /* the signal of the route is green */
       (signalStatus(signal(route)) = green)  & 
       /* points locked for the route */
       currentLocks[{route}] = lockTable[{route}] &
       /* the route is clear */
       clearTable(route) <: emptyTracks 
       /* no train is in the track preceding the route (i.e. nothing close enough to go through the red light ) */ 
       & homeSignal(signal(route)) : emptyTracks
    THEN 
      /* signal of route to red */
      signalStatus(signal(route)) := red ||
      /* release the locks associated with the route */
      currentLocks := {route} <<| currentLocks ||
      bb := yes
    ELSE
      bb := no
    END
   END /* let */
  END    

END

