MACHINE DJTopology

/* Date: Thu Aug 07 16:16:11 BST 2014
 * Notes: supporting doubleJunction.bjoernercomplete model
 * Automatically generated by TrackScheme2CSPB tool version 0.1
 * Authors of Tool: Phillip James and Matthew Trumble
 * Authors: Moller, Nguyen, Roggenbach, Schneider, Treharne
 *  Corresponding Authors: S.Schneider@surrey.ac.uk, H.Treharne@surrey.ac.uk
 *
 */
 
[%
var bMachine1 = BMachine!Machine.all().first();
%]

SEES  DJContext

/*

signal: the signal associated with a route
homeSignal: the track where the signal is situated
homePoints: the track where the points are situated
next: the relation between tracks and possible successor tracks
staticNext: the successors of tracks which are independent of point positions
dynamicNext: the successors of tracks which are dependent on point positions and the dependency is included in the function

Note: if tracks go in different directions then homeSignal need not be injective
*/
/* egl */
CONSTANTS
    signal, homeSignal, homePoints, next, staticNext, dynamicNext

PROPERTIES
                   
     signal : ROUTE --> SIGNAL &
     homeSignal : SIGNAL >-> TRACK &
     homePoints : POINTS --> TRACK &
     next : TRACK <-> TRACK &
     staticNext : TRACK +-> TRACK &
     dynamicNext : (POINTS * POINTPOSITION) +-> (TRACK * TRACK) &
     staticNext - { (t,Exit) | t : TRACK } : TRACK >+> TRACK &
 
    /* every next is dependent on a point position or it is not.
     * Note: for any particular set of points and their status there will be at 
     * most one next track and at most one previous track (this is not explicitly stated)
     */

    next = staticNext \/ ran(dynamicNext) &
    dom(staticNext) /\ dom(ran(dynamicNext)) = {} &
    ran(staticNext) /\ ran(ran(dynamicNext)) = {} &


[%
for (p in bMachine1.hasProperties)
{
	out.print( p.write() );
	if (hasMore) {out.println(" &");}
}
%]


END

[%

operation BMachine!BSet write() : String {

	var toReturn = "    " + self.name + " = {";
	
	for (el in self.hasSetElements)
	{
		toReturn = toReturn + el.name;
		
		if (hasMore) {toReturn = toReturn + ", ";}
	}
	
	toReturn = toReturn + "};";
	return toReturn;
}

operation BMachine!BSet writeElements() : String {
	
	var toReturn = "{";
	
	for (el in self.hasSetElements) {
	
		toReturn = toReturn + el.name;
		
		if (hasMore) {toReturn = toReturn + ",";}
	}
	
	toReturn = toReturn + "}";
	return toReturn;

}

operation BMachine!Property write() : String {
	
	var toReturn = "    " + self.name + " = {";
	
	for (pe in self.hasPropElements) {
		
		// print domain elements
		for (de in pe.hasDomainElements) {
			
			// if more than one element enclose in brackets
			if ((loopCount = 1) and hasMore) {toReturn = toReturn + "(";}
			
			toReturn = toReturn + de.name;
			if (hasMore) {toReturn = toReturn + ",";}
				
			// close brackets if appropriate
			if ((not hasMore) and (loopCount > 1)) {toReturn = toReturn + ")";}
		}
		
		// if range set is present
		if (pe.hasRangeSet.isDefined()) {
			
			// print |->
			toReturn = toReturn + " |-> ";
			
			// print set
			toReturn = toReturn + pe.hasRangeSet.writeElements();
		}
		
		// print range elements
		for (re in pe.hasRangeElements) {
		
			// print |->
			if (loopCount = 1) {toReturn = toReturn + " |-> ";}
			
			// if more than one element enclose in brackets
			if ((loopCount = 1) and hasMore) {toReturn = toReturn + "(";}
			
			toReturn = toReturn + re.name;
			if (hasMore) {toReturn = toReturn + ",";}
				
			// close brackets if appropriate
			if ((not hasMore) and (loopCount > 1)) {toReturn = toReturn + ")";}
		}
		
		if (hasMore) {toReturn = toReturn + ", ";}
	}
	
	toReturn = toReturn + "}";
	return toReturn;
}

%]

