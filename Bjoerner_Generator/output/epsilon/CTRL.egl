{-
 Date: Thu Aug 07 14:23:24 BST 2014
 Notes:  CSP Controller for doubleJunction.bjoernercomplete model with 2 train 
 Generated by: Automatically produced by Version 0.1 of TrackScheme2CSPB tool
 Authors of Tool: Phillip James and Matthew Trumble
 Authors of Model: Moller, Nguen, Roggenbach, Schneider, Treharne
 Corresponding Authors: S.Schneider@surrey.ac.uk, H.Treharne@surrey.ac.uk
 
 Description: 
 A CSP process to guide the Interlocking.mch

 First open the Interlocking.mch file as usual in ProB
 Then select the menu item
        Menu -> File -> Open Special -> Use CSP File to Guide B
 You have to be in normal mode to see this menu item (not in beginner mode)

 Comments: This model describes the train behaviour of an open system with trains exiting and remaining on the exit track. 

 
-}
[%
var cspScript1 : CSP!CSPScript;
cspScript1 := CSP!CSPScript.all().at(0);
%]

-- datatype definitions corresponding to those given in the Context.mch
datatype TRAIN = albert | bertie

datatype SIGNAL = red | green
[%
for (dt in cspScript1.dataType)
{
	if( dt.isDefined() ) --  and not(dt.name.isNativeCSPType())) 
	{
		out.println( dt.write(0) );
		--out.println();
	}
}
%]
datatype ANSWERS = yes | no

--both these sets defined the end points of an open system
[%
for (st in cspScript1.set)
{
	out.println( st.write(0) );
}
%]
ALLTRACK = POS
TRACK = diff(ALLTRACK,{nullTrack})

--the rest of this file is the same for all track plans
-- define channels with names that correspond to the B operations in the Interlocking.mch
channel enter: TRAIN.ENTRY
channel exit: TRAIN.EXIT
channel nextSignal : TRAIN.SIGNAL
channel move : TRAIN.ALLTRACK.ALLTRACK
channel request : ROUTE.ANSWERS
channel release : ROUTE.ANSWERS
--definition of error channels
channel collision, derailment, runthrough, occupiedgreen, offdesignated


--controller process to deal with route requests and releasing of routes
RW_CTRL =
  ([] r : ROUTE @ request!r?ans -> RW_CTRL)
  []
  ([] r : ROUTE @ release!r?ans -> RW_CTRL)  

--definition of individual train control process
--each train starts off the track plan and after leaving remains on the exit track
TRAIN_OFF(t) = 
  [] entryPos : ENTRY  @
    enter!t!entryPos -> TRAIN_ENTERED(t,entryPos)

TRAIN_ENTERED(t,entryPos) = 
    nextSignal!t?aspect?flag ->
   (if (aspect==green or flag == false) then
       move.t.entryPos?newp -> TRAIN_CTRL(t,newp)
    else
    ((move.t.entryPos?newp -> STOP) |~| TRAIN_ENTERED(t,entryPos))
   -- allow an entry to go through a red with an overlap
   -- TRAIN_ENTERED(t,entryPos)
   )



TRAIN_CTRL(t,pos) =
--if an exit track it must leave the system
(member(pos,EXIT) & exit.t.pos -> STOP  )
[]
-- it is not an exit track and there is no signal
(not(member(pos,EXIT)) and
 not(member(pos,SIGNALHOMES)) & 
   move.t.pos?newp -> TRAIN_CTRL(t,newp)
)
[]
-- there is a signal on the track, track is not exit
(not(member(pos,EXIT)) and
 member(pos,SIGNALHOMES)  & 
   (nextSignal!t?aspect?flag ->
   (if (aspect==green or flag == false) then
       move.t.pos?newp -> TRAIN_CTRL(t,newp)
    else
       ((move.t.pos?newp -> STOP) |~| TRAIN_CTRL(t,pos))
   )
   []
   changeDirection.t.pos -> TRAIN_CTRL(t,pos))
)


-- if the track is a buffer then the only thing it can do is change direction and then move 
-- if there was a signal on the track then the synchronisation with the train process means that it would first read the signal
-- if it was red it would simply go through the signal
 TRAIN_BUFFER_CTRL(b,t) = move!t?p!b -> changeDirection.t.b -> move.t.b?newp -> TRAIN_BUFFER_CTRL(b,t)
ALL_BUFFER = ||| b : BUFFER, t : TRAIN @ TRAIN_BUFFER_CTRL(b,t)

A_ALL_BUFFER = union(union(
       { move.t.p.b | t <- TRAIN, p<-ALLTRACK, b<-BUFFER},
       { move.t.b.p | t <- TRAIN, p<-ALLTRACK, b<-BUFFER}),
       {|changeDirection|})

ALL_TRAINS = ||| t : TRAIN @ TRAIN_OFF(t)
A_ALL_TRAINS = {| enter,exit, nextSignal, move|}

--ALL_TRAINS_WITH_BUFFER = ALL_TRAINS
ALL_TRAINS_WITH_BUFFER = ALL_TRAINS [A_ALL_TRAINS || A_ALL_BUFFER] ALL_BUFFER

ERR = (collision -> ERR) [] 
      (runthrough -> ERR) [] 
      (derailment -> ERR) [] 
      (occupiedgreen -> ERR) [] 
      (offdesignated -> ERR) 

CTRL = (RW_CTRL ||| ERR) 
CTRL_WITH_BUFFER = CTRL ||| ALL_TRAINS_WITH_BUFFER

MAIN = CTRL_WITH_BUFFER

[%

@cached
operation Integer indent() : String {
	var indentation : String := '';
	var i: Integer := 0;
	while(i < self) {
		indentation := indentation + '';
		i := i + 1;
	}
	return indentation;
}

operation DatatypeItemList write(i : Integer) : String 
{
	var indt : String := i.indent();
	var toReturn : String := '';
	
	if(self.size > 0) 
	{
		var ppli : DatatypeItem := self.firstItem;
		toReturn := indt;
		var sep : String := '';
		
		while(ppli.isDefined()) 
		{
			toReturn := toReturn + sep + ppli.name;
			ppli := ppli.preceeds;
			sep := ' | ';
			--ppli.name.println('<><><><<><><><><><>');
		}

	}
	return toReturn;
}

operation Datatype write(i : Integer) : String 
{
	var indt : String := i.indent();
	var nm : String := '';
	
	if(self.typeName.isDefined() and self.itemList.isDefined()) 
	{
			nm := indt + 'datatype ' + self.typeName + ' = ' + self.itemList.write(i + 1);
	}
		
	return nm;
}


operation SET write(i : Integer) : String 
{
	var toReturn : String;
	if(not(self.name = '')) 
	{
		var indt : String := i.indent();
		toReturn:= indt+self.name+' = '+(i+1).indent() + '{ ';
		var sep : String := '';
		
		for(el in self.item) 
		{
			if(el.item.isDefined()) -- mutually exclusive: either is a typeditem or event 
			{ 
				toReturn := toReturn + sep + el.item.name ;
			} 
			else 
			{
				toReturn := toReturn + sep + el.event.writeEvent(true);
			}
			sep := ', ';
		}
		
		toReturn := toReturn + ' }';
	}
	else 
	{
		toReturn := '';
	}
	return toReturn;
}

%]
